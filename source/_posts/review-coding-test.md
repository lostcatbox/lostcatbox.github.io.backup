---
ㅈtitle: review-coding-test
date: 2020-10-27 21:17:10
categories: [Review]
tags: [Coding, Skill, Basic]
---

# 왜?

코테 준비

![스크린샷 2020-10-27 오후 9.16.29](https://tva1.sinaimg.cn/large/0081Kckwgy1gk45ocdb2sj30oe18wx6p.jpg)

이대로 그대로 따라갈것이다

# 2장

문제를 푸는 것이 중요한 것이 아니라 문제를 푸는 기술을 연마하는 것이중요하다

이를 위해서는 자신이 문제를 어떤 방식으로 해결하는지를 의식하고 어느 부분이 부족한지, 어떤 부분을 개선해야 할지 파악해야 합니다. 실력을 늘리기 위해서는 문제 푸는 과정을 여러 부분으로 나눠 보고 각 과정을 자신이 잘하고 있는지, 그리고 잘하지 못하는 것이 있다면 어떤 방향으로 개선해야 하는지를 끈임없이 파악해야한다. 

## 2.2 문제 해결 과정

리처드 파인만이 사용한 알고리즘. 칠판에 문제를 적는다>생각한다>칠판에 답안을 적는다. 문제풀이를 단계별로 나눈다는 아이디어를 얻어내자. 특히, 문제를 적는다는 단계는 문제를 읽고 이해한 뒤 자신의 언어를 이용해 재정의를 해야하기 때문에 중요하다. 

### 6단계 문제 해결 알고리즘

1. 문제를 일고 이해한다
2. 문제를 익숙한 용어로 재정의한다
3. 어떻게 해결할지 계획을 세운다
4. 계획을 검증한다.
5. 프로그램으로 구현한다
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다

### 문제를 읽고 이해하기

강조강조.. 문제를 일고 이해하는것. 모든 대회 참가자들이 공통으로 하는 실수가 있다면 바로 문제를 잘못 읽는 실수떄문이다. 조급한 마음>곁눈질>그림만봄>큰대가를 치룬다. 

문제의 궁극정인 목적부터 사소한 제약 조건까지 모두 이해하고 넘어가야한다. ~~큰 댓가를 치기 싫다면~~

### 재정의와 추상화

자신이 다루기 쉬운 개념을 이용해서, 문제를 자신의 언어로 풀어 쓰는 것이다. 문제가 요구하는 바를 직관적으로 이해하기 위해 꼭 필요, 복잡한 문제일수록 더 중요함.

문제의 추상화: 현실을 본질만 남겨두고 축약하여 다루기 쉽게 표현하는 것.

문제의 본질을 어떤 방식으로 재구성하느냐에 따라 같은 일을 하는 프로그램이라도 전혀 다른 문제로 받아들여질 수 있습니다. 추상화의 방법에 따라 어려운문제>쉽게품 or 쉬운문제>어렵게품..

어떤 부분을 추상화할 것인지를 선택하는 작업과 문제를 재정의하는 방법들에 대한 고찰은 필수과정이다. 반드시 연습하자

### 계획 세우기

__가장 중요한 단계__ 

문제를 어떻게 해결할지 계획을 세우는 것이다. 문제를 어떤 방식으로 해결할지 결정하고, 사용할 알고리즘과 자료 구조를 선택한다. 아마 문제를 보고 어떻게 해결해야 할지 곧장 떠오르지 않는 어려운 문제의 경우 이 과정에서 가장 많은 고민함. (2.3)

### 계획 검증하기

계획후에 키보드x

구현을 시작하기 전에 계획을 검증하는 과정을 거쳐야한다.

우리가 설계한 알고리즘이 모든 경우에 요구 조건을 정확히 수행하는지를 증명하고, 수행에 걸리는 시간과 사용하는 메모리가 문제의 제한 내에 들어가는지 확인해야한다. (4,5장)

### 계획 수행하기

프로그램을 작성, 구현이 부정확하거나 비효율적이면 프로그램은 쓰레기다

(3장)

### 회고하기

__장기적으로 가장 큰 영향을 미치는 단계__

자신이 문제를 해결한 과정을 돌이켜 보고 개선하는 과정... 문제를 한번만 풀어서는 그 문제에서 배울 수 있는 것들을 다 배우지못한다.

2번째 풀때는 더 효율적인 알고리즘을 찾거나 간결한 코드를 작성, 같은 알고리즘을 유도할 수 있는 더 직관적인 방법을 찾을 수도있다. 자신이 문제 해결 기술을 어떻게 사용하고 있는지를 돌이켜보고 개선해야한다

효과적으로 회고하는 방법은 문제를 풀때마다 코드와 함께 자신의 경험을 기록으로 남기는 것이다.

__간단한 해법,어떤 방식 접근, 문제의 해법을 찾는 데 결정적인 깨달음을 간단히 기록해보기__ 

반대로 한 번에 맞추지 못한 경우에도 오답 원인도 꼭 적는 것이좋다. 실수를 통해 배우기. 반복하게 되는 실수를 확인하고 이를 인지하면 실수를 줄이는 노력을 하게된다. 기록을 쌓는다.

마지막 공통된 회고 방법은 같은 문제를 해결한 다른 사람의 코드를 보는 것이다. 같은 문제를 비슷한 알고리즘으로 해결한 사람의 코드도 다다르다. 다른 사람과 함께 하자. 다른 통찰을 얻을 수 있다.

__문제를 풀지 못할 때__

문제를 직접 풀기 전에는 절대로 답안을 참조하지 말라는 말도 있지만, 초보 시절에는 한 문제에 너무 매달려 있는 것도 좋지 않다. 일정 시간이 지나도록 고민해도 안되면 다른 사람의 소스 코드나 풀이를 참조하자는 원칙을 세우고 접근하자

다른 사람의 소스 코드나 풀이를 참조할때 반드시 나를 돌아봐야한다. __나는 왜 이 풀이를 떠올리지 못했는가?, 내가 했던 접근은 틀렸나?__ 는 질문들의답을 찾아야한다.

처음 보는 기술이나 접근을 한번만에 자신의 것으로 하기는 힘들지만, 여러번 반복해서 이용하며 풀다보면 비슷한 문제는 해당 기법이 떠오를 것이다

## 문제 해결 전략 (계획 세우기 단계)

자신이 알고 있는 기술을 직접적으로 적용할수 있는 단순한 문제 말고 어려운 문제일수록 다양한 방법을 시도해 보면서 답안을 찾아야합니다. 답안을 읽을 때 어떤 방식으로 접근했는지를 눈여겨보자

### 직관과 체계적인 접근

가장 중요한 것은 __문제와 답의 구조에 대한 직관의 중요성이다.__ 직관은 해당 문제를 해결하는 알고리즘이 대략적으로 어떤 형태를 가질지 짐작하게해준다. 이 기술은 막막한 문제들을 해결하며 경험을 쌓아야한다. 그럼 막막한 문제는 어떻게 처음해결할까? 그냥 아이디어가 떠오르길 기대하면서 멍하게 있기보다는, 좀더 체계적으로 생각해보는것이다. 문제 해결의 좋은 시작점역할이될수있다.

### 체계적인 접근을 위한 질문들

문제를 해결할 때  유용한 질문목록!(가장 도움많이되는 질문순), 문제마다 사용처 제한이있을수도있음

__비슷한 문제를 풀어본 적이 있나?__

문제의 원리르 완전히 이해해야 변형되어도 비슷한 문제로 인식후 풀수있다.

문제의 형태가 비슷하지 않더라도 문제의 목표가 같은 경우 또한 비슷한 문제다. 

__단순한 방법에서 시작할 수 있을까?__

비슷한 문제를 본적없거나 적용되지않는다면, 무식한 방법으로 풀수있을까? 질문을 합니다. 시간과 공간 제약을 생각하지 않고 문제를 해결할 수 있는 가장 단순한 알고리즘을 만드는것. 이 전략 목표는 간단하게 풀수있는 문제를 너무 복잡하게 생각해서 어렵게 푸는 실수를 예방하는 것.  또한 효율적인 알고리즘이라도 단순한 알고리즘을 기반으로 구성된 경우가 많이 때문이다. 이런 경우 좀더 효율적인 자료 구조를 사용하거나, 계산 과정에서 같은 정보를 두번 중복으로 계산하지 않는 등의 최적화를 적용해서 빨라질 때 까지 알고리즘을 개석하는 식으로 문제 풀수있다. 사고 과정의 큰 도약을 필요하지않고, __어려운 문제를 접했을때 한번쯤 시도해 볼만하다.__

또한 단순한 방법은 알고리즘 효율성을 체크할수있다. 새로운 알고리즘이 단순한 알고리즘에 비해 얼마나 개선되었는지 재는 용도로 사용해보자. 

이런 기법을 사용하는 풀이의 예로 쿼드 트리 뒤집기(7장 연습문제)가 있다

__내가 문제를 푸는 과정을 수식화할 수 있을까?__

점진적인 접근 방식이 만능은 아니다. 처음 생각한 것과 완전히 다른, 새로운 방향에서 접근해야 풀리는 문제들도 있다. __번뜩이는 영감이 필요한 문제를 만났을때는 그냥 손으로 문제에 주어진 예제 입력을 직접 해결해 보는 것이다. 자신이 문제를 해결한 과정을 공식화해서 답을 만드는 알고리즘을 만들수있다. 또한 이과정에서 어떤 점을 고려해야 하는지 알게 된다.__

프로그램 다 작성하고, 디버깅하는도중에 어떤 점을 고려해야하는지 놓쳤다면 처음부터 다시 다짜는 비극이 나올수도ㅠㅠ

__문제를 단순화할 수 없을까?__

또 다른 강력한 문제 해결 도구는 주어진 문제의 좀더 쉬운 변형판을 먼저 풀어 보는것이다. 문제를 쉽게 변형하는 방법은 여러가진다

__문제의 제약 조건을 없애보기, 계산해야 하는 변수의 수를 줄이기, 다차원의 문제를 1차원으로 줄여 표현__

위에 방법들은 단순화된 문제의 해법이 원래 문제의 해법에 대한 직관을 제공, 직접적으로 이용해 원래 문제를 풀수도있다.

__그림으로 그려볼 수 있을까?__

문제에 관련된 그림을 그려 보는 것이다. 도형이 직관적으로 받아들이기 때문이다. 

__수식으로 표현할 수 있을까?__

편문으로 쓰여 있는 문제를 수식으로 표현하는 것도 도움된다. 수식을 전개하거나 축약하는 것은 도움을 준다

__문제를 분해할 수 있을까?__

더 다루기 쉬운 형태로 문제를 변형 하는것이다

예를 들어 문제의 제약 조건을 분해하는 방법

즉, 한개의 복잡한 조건보다 여러 개의 단순한 조건이 다루기 쉽기 때문에 변형한다.

예를 들면 A 전체 기록과 B 달리기 전체 기록이 겹칠확률이 있을라면 결국 Aworst>=Bbest 아니면서 동시에 Bworst>=Abest 가 아니라면 기록은 겹칠수밖에없다. 조건 두개로 나눔!

__뒤에서부터 생각해서 문제를 풀수 있을까?__

문제에 내재된 순서를 바꿔 보는 것이다

A에서 B로 가는 방법을 찾기 어렵지만 B에서 A로 가는 방법을 찾기 쉬울때

__순서를 강제할 수 있을까?__

순서가 없는 문제에 순서를 강제해서 문제를 푸는 방법도 있다. 

__특정 형태의 답만을 고려할 수 있을까?__

순서를 강제하는 기법의 연장선으로 정규화 기법이 있다. 정규화란 우리가 고려해야 할 답들 중 형태가 다르지만 결과적으로 똑같은 것들을 그룹으로 묶은 뒤, 각 그룹의 대표들만 고려하는방법이다.

# 3장

## 3.1

알고리즘과 자료구조를 모두알기도힘들고, 특정 문제에서 쓰인다. 하지만 코딩은 모든 문제풀이에 쓰이므로 중요하다. 코드는 일기 쉬운 코드를 목표로 작성해야한다. 디버깅도 쉬워지고, 한번에 정확하게 작성하기 어렵기때문이다. 자신의 코드 스타일을 간결하고 일관되게 다듬으려고 노력해야한다. 

## 3.2 좋은 코드를 짜기 위한 원칙



### 간결한 코드 작성

가장 간결한 코드를 작성하자. 코드가 짧을수록 오타나 단순한 버그가 생길 우려가 줄어들고, 디버깅도 쉬워진다.

모든 부분은 일반적인 회사에서 잘 짠 코드와 같은 지향점을 가지고 있지만 프로그래밍 대회에서 더 좋은 도구도있다. 예를 들면 전역 변수의 광범위한 사용이다. 매크로를 사용(C++에 해당)

### 적극적으로 코드 재사용하기

코드를 모듈화 하자! 

같은 코드가 반복된다면 이들을 함수나 클래스로 분리해서 재사용하는 것이다. __같은 코드가 세 번 이상 등장한다면 항상 해당 코드를 함수로 분리해 재사용하는 것을 기본 윈칙으로하자__. 디버깅 시간도 엄청나게 줄어든다.

이상적인 세계에서는 한 함수가 두가지 이상의 일을 해서는 안된다고 말한다. 입력을 읽어들이는 함수, 입력을 처리하기 쉬운 형태로 바꾸는 함수, 실제 문제를 푸는 함수 각각 분리되어 있어야한다는 소리다. 하지만 대부분 프로그래밍 대회에서는 이정도로 엄격하게 안한다.

### 표준 라이브러리 공부하기

내가 배열, 큐, 스택, 리스트, 딕셔너리를 직접짜기보다는(이해는 필요), 표준 라이브러리를 사용하자.

### 항상 같은 형태로 프로그램을 작성하기

문제를 풀다보면 여러 종류의 코드를 반복적으로 짜게된다. 이분법, 그래프의 너비 우선 탐색,,,알고리즘, 자료구조등.. 매우 자주 작성하게된다

 for while문도 바꾸고, 크기 가로 순으로 전달하다가 가로, 세로 순으로 전달하고 코드작성할때마다 바뀔수도있다. 하지만 이는 디버깅에 불리하다. 한번 검증된 과정 코드가 있다면 작성하고 이것만 꾸준히 사용하자.

### 일관적이고 명명법 사용하기

사용하는 언어의 표준 라이브러리에서 사용하는 명명 규약을 익히자. 모호한 명명법은 때로 잡아내기 힘든 오류를 만들어낸다

```python
def judge(y,x,cy,cx,cr)
```

judge함수는 언제 `true` 를 반환할지모른다. 디버깅할때 힘들수도있다

```python
def isInsideCircle(y,x,cy,cx,cr)
```

이렇게 함수명을 정의한다면 점이 원안에 있을때 `ture`  를 반환한다고 알수있다.

### 모든 자료를 정규화해서 저장하기

같은 자료를 두 가지 형태로 저장하지 않는 것이 중요하다. 예를 들어 유리수를 표현하는 클래스(C++기준)을 작성한다고하면, 이때 입력받는 유리수를 항상 약분해 기약 분수로 표현하는 것이 좋다. 그렇지 않는 다면 9/6, 3/2를 표현하는 변수가 따로 존재하게된다. 

다른 예로는 시간은 UTC시간, 문자열을 다루는 프로그램은 외부에서 문자열을 읽어들이자마자 UTF-8 인코딩으로 변환해야만 문자열을 다루기 훨씬 편해진다.

__즉, 정규화는 프로그램이 외부에서 자료를 입력받거나 계산하자마자 곧장 이뤄저야한다.__ 

### 코드와 데이터를 분리하기

날짜를 다루는 프로그램을 작성하는데, 날짜를 출력할떄 월을 숫자가 아니라 영문 이름으로 출력해야한다하자.. 초보자는 12줄 짜리 if문을 써서 하겠지..

코드의 논리와 상관 없는 데이터는 가능한 부리하는 것이좋다. 각 월의 영어 이름을 다음과 같은 테이블로 만드는 것으로 해결가능하다.

```python
month_name = ["January", "Februray"....]

#다른예시로 체스 기사가 움직일수있는 상대좌표8가지
knight= [2,2,-2,-2,1,1,-1,-1]
```

### 자주하는 실수

__같은 실수를 반복하지말고, 실수에서 배우는 것이 좋고, 남의 실수로부터 배워 유사한 실수를 저지르지 않는것이 최고다__

자주하는 실수모음

__산술 오버플로__

실수를 계산 과정에서 변수의 표현 범위를 벗어나는 값을 사용하는것. (3.5참조)

__배열 범위 밖 원소에 접근__

배열 범위 밖의 원소에 접근하는 오류!

__일관되지 않은 범위 표현 방식 사용하기__

배열의 잘못된 위치를 참조하는 오류가 발생하는 큰 원인중 하나로, 프로그램 내에서 여러 가지의 범위 표현 방식을 섞어 쓰는 경우가 있다. 

예를 들면 1~12의 수의 범위를 나타낼때 닫힌 범위인 1<=x<=12를 사용하고 (공집합표현시 어려움), 열린범위는 0<x<13임을 잘 고려해야한다. (시작이 0일때는 -1로 써야하므로 어색해진다)

우리는 첫번째 시작하는 값은 포함하고 마지막 값은 포함하지 않게 쓰자

1<=x<13으로 쓰자!     Like `[1,13)`



