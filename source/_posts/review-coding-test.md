---
ㅈtitle: review-coding-test
date: 2020-10-27 21:17:10
categories: [Review]
tags: [Coding, Skill, Basic]
---

# 왜?

코테 준비

![스크린샷 2020-10-27 오후 9.16.29](https://tva1.sinaimg.cn/large/0081Kckwgy1gk45ocdb2sj30oe18wx6p.jpg)

이대로 그대로 따라갈것이다

# 2장

문제를 푸는 것이 중요한 것이 아니라 문제를 푸는 기술을 연마하는 것이중요하다

이를 위해서는 자신이 문제를 어떤 방식으로 해결하는지를 의식하고 어느 부분이 부족한지, 어떤 부분을 개선해야 할지 파악해야 합니다. 실력을 늘리기 위해서는 문제 푸는 과정을 여러 부분으로 나눠 보고 각 과정을 자신이 잘하고 있는지, 그리고 잘하지 못하는 것이 있다면 어떤 방향으로 개선해야 하는지를 끈임없이 파악해야한다. 

## 2.2 문제 해결 과정

리처드 파인만이 사용한 알고리즘. 칠판에 문제를 적는다>생각한다>칠판에 답안을 적는다. 문제풀이를 단계별로 나눈다는 아이디어를 얻어내자. 특히, 문제를 적는다는 단계는 문제를 읽고 이해한 뒤 자신의 언어를 이용해 재정의를 해야하기 때문에 중요하다. 

### 6단계 문제 해결 알고리즘

1. 문제를 일고 이해한다
2. 문제를 익숙한 용어로 재정의한다
3. 어떻게 해결할지 계획을 세운다
4. 계획을 검증한다.
5. 프로그램으로 구현한다
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다

### 문제를 읽고 이해하기

강조강조.. 문제를 일고 이해하는것. 모든 대회 참가자들이 공통으로 하는 실수가 있다면 바로 문제를 잘못 읽는 실수떄문이다. 조급한 마음>곁눈질>그림만봄>큰대가를 치룬다. 

문제의 궁극정인 목적부터 사소한 제약 조건까지 모두 이해하고 넘어가야한다. ~~큰 댓가를 치기 싫다면~~

### 재정의와 추상화

자신이 다루기 쉬운 개념을 이용해서, 문제를 자신의 언어로 풀어 쓰는 것이다. 문제가 요구하는 바를 직관적으로 이해하기 위해 꼭 필요, 복잡한 문제일수록 더 중요함.

문제의 추상화: 현실을 본질만 남겨두고 축약하여 다루기 쉽게 표현하는 것.

문제의 본질을 어떤 방식으로 재구성하느냐에 따라 같은 일을 하는 프로그램이라도 전혀 다른 문제로 받아들여질 수 있습니다. 추상화의 방법에 따라 어려운문제>쉽게품 or 쉬운문제>어렵게품..

어떤 부분을 추상화할 것인지를 선택하는 작업과 문제를 재정의하는 방법들에 대한 고찰은 필수과정이다. 반드시 연습하자

### 계획 세우기

__가장 중요한 단계__ 

문제를 어떻게 해결할지 계획을 세우는 것이다. 문제를 어떤 방식으로 해결할지 결정하고, 사용할 알고리즘과 자료 구조를 선택한다. 아마 문제를 보고 어떻게 해결해야 할지 곧장 떠오르지 않는 어려운 문제의 경우 이 과정에서 가장 많은 고민함. (2.3)

### 계획 검증하기

계획후에 키보드x

구현을 시작하기 전에 계획을 검증하는 과정을 거쳐야한다.

우리가 설계한 알고리즘이 모든 경우에 요구 조건을 정확히 수행하는지를 증명하고, 수행에 걸리는 시간과 사용하는 메모리가 문제의 제한 내에 들어가는지 확인해야한다. (4,5장)

### 계획 수행하기

프로그램을 작성, 구현이 부정확하거나 비효율적이면 프로그램은 쓰레기다

(3장)

### 회고하기

__장기적으로 가장 큰 영향을 미치는 단계__

자신이 문제를 해결한 과정을 돌이켜 보고 개선하는 과정... 문제를 한번만 풀어서는 그 문제에서 배울 수 있는 것들을 다 배우지못한다.

2번째 풀때는 더 효율적인 알고리즘을 찾거나 간결한 코드를 작성, 같은 알고리즘을 유도할 수 있는 더 직관적인 방법을 찾을 수도있다. 자신이 문제 해결 기술을 어떻게 사용하고 있는지를 돌이켜보고 개선해야한다

효과적으로 회고하는 방법은 문제를 풀때마다 코드와 함께 자신의 경험을 기록으로 남기는 것이다.

__간단한 해법,어떤 방식 접근, 문제의 해법을 찾는 데 결정적인 깨달음을 간단히 기록해보기__ 

반대로 한 번에 맞추지 못한 경우에도 오답 원인도 꼭 적는 것이좋다. 실수를 통해 배우기. 반복하게 되는 실수를 확인하고 이를 인지하면 실수를 줄이는 노력을 하게된다. 기록을 쌓는다.

마지막 공통된 회고 방법은 같은 문제를 해결한 다른 사람의 코드를 보는 것이다. 같은 문제를 비슷한 알고리즘으로 해결한 사람의 코드도 다다르다. 다른 사람과 함께 하자. 다른 통찰을 얻을 수 있다.

__문제를 풀지 못할 때__

문제를 직접 풀기 전에는 절대로 답안을 참조하지 말라는 말도 있지만, 초보 시절에는 한 문제에 너무 매달려 있는 것도 좋지 않다. 일정 시간이 지나도록 고민해도 안되면 다른 사람의 소스 코드나 풀이를 참조하자는 원칙을 세우고 접근하자

다른 사람의 소스 코드나 풀이를 참조할때 반드시 나를 돌아봐야한다. __나는 왜 이 풀이를 떠올리지 못했는가?, 내가 했던 접근은 틀렸나?__ 는 질문들의답을 찾아야한다.

처음 보는 기술이나 접근을 한번만에 자신의 것으로 하기는 힘들지만, 여러번 반복해서 이용하며 풀다보면 비슷한 문제는 해당 기법이 떠오를 것이다

## 문제 해결 전략 (계획 세우기 단계)

자신이 알고 있는 기술을 직접적으로 적용할수 있는 단순한 문제 말고 어려운 문제일수록 다양한 방법을 시도해 보면서 답안을 찾아야합니다. 답안을 읽을 때 어떤 방식으로 접근했는지를 눈여겨보자

### 직관과 체계적인 접근

가장 중요한 것은 __문제와 답의 구조에 대한 직관의 중요성이다.__ 직관은 해당 문제를 해결하는 알고리즘이 대략적으로 어떤 형태를 가질지 짐작하게해준다. 이 기술은 막막한 문제들을 해결하며 경험을 쌓아야한다. 그럼 막막한 문제는 어떻게 처음해결할까? 그냥 아이디어가 떠오르길 기대하면서 멍하게 있기보다는, 좀더 체계적으로 생각해보는것이다. 문제 해결의 좋은 시작점역할이될수있다.

### 체계적인 접근을 위한 질문들

문제를 해결할 때  유용한 질문목록!(가장 도움많이되는 질문순), 문제마다 사용처 제한이있을수도있음

__비슷한 문제를 풀어본 적이 있나?__

문제의 원리르 완전히 이해해야 변형되어도 비슷한 문제로 인식후 풀수있다.

문제의 형태가 비슷하지 않더라도 문제의 목표가 같은 경우 또한 비슷한 문제다. 

__단순한 방법에서 시작할 수 있을까?__

비슷한 문제를 본적없거나 적용되지않는다면, 무식한 방법으로 풀수있을까? 질문을 합니다. 시간과 공간 제약을 생각하지 않고 문제를 해결할 수 있는 가장 단순한 알고리즘을 만드는것. 이 전략 목표는 간단하게 풀수있는 문제를 너무 복잡하게 생각해서 어렵게 푸는 실수를 예방하는 것.  또한 효율적인 알고리즘이라도 단순한 알고리즘을 기반으로 구성된 경우가 많이 때문이다. 이런 경우 좀더 효율적인 자료 구조를 사용하거나, 계산 과정에서 같은 정보를 두번 중복으로 계산하지 않는 등의 최적화를 적용해서 빨라질 때 까지 알고리즘을 개석하는 식으로 문제 풀수있다. 사고 과정의 큰 도약을 필요하지않고, __어려운 문제를 접했을때 한번쯤 시도해 볼만하다.__

또한 단순한 방법은 알고리즘 효율성을 체크할수있다. 새로운 알고리즘이 단순한 알고리즘에 비해 얼마나 개선되었는지 재는 용도로 사용해보자. 

이런 기법을 사용하는 풀이의 예로 쿼드 트리 뒤집기(7장 연습문제)가 있다

__내가 문제를 푸는 과정을 수식화할 수 있을까?__

점진적인 접근 방식이 만능은 아니다. 처음 생각한 것과 완전히 다른, 새로운 방향에서 접근해야 풀리는 문제들도 있다. __번뜩이는 영감이 필요한 문제를 만났을때는 그냥 손으로 문제에 주어진 예제 입력을 직접 해결해 보는 것이다. 자신이 문제를 해결한 과정을 공식화해서 답을 만드는 알고리즘을 만들수있다. 또한 이과정에서 어떤 점을 고려해야 하는지 알게 된다.__

프로그램 다 작성하고, 디버깅하는도중에 어떤 점을 고려해야하는지 놓쳤다면 처음부터 다시 다짜는 비극이 나올수도ㅠㅠ

__문제를 단순화할 수 없을까?__

또 다른 강력한 문제 해결 도구는 주어진 문제의 좀더 쉬운 변형판을 먼저 풀어 보는것이다. 문제를 쉽게 변형하는 방법은 여러가진다

__문제의 제약 조건을 없애보기, 계산해야 하는 변수의 수를 줄이기, 다차원의 문제를 1차원으로 줄여 표현__

위에 방법들은 단순화된 문제의 해법이 원래 문제의 해법에 대한 직관을 제공, 직접적으로 이용해 원래 문제를 풀수도있다.

__그림으로 그려볼 수 있을까?__

문제에 관련된 그림을 그려 보는 것이다. 도형이 직관적으로 받아들이기 때문이다. 

__수식으로 표현할 수 있을까?__

편문으로 쓰여 있는 문제를 수식으로 표현하는 것도 도움된다. 수식을 전개하거나 축약하는 것은 도움을 준다

__문제를 분해할 수 있을까?__

더 다루기 쉬운 형태로 문제를 변형 하는것이다

예를 들어 문제의 제약 조건을 분해하는 방법

즉, 한개의 복잡한 조건보다 여러 개의 단순한 조건이 다루기 쉽기 때문에 변형한다.

예를 들면 A 전체 기록과 B 달리기 전체 기록이 겹칠확률이 있을라면 결국 Aworst>=Bbest 아니면서 동시에 Bworst>=Abest 가 아니라면 기록은 겹칠수밖에없다. 조건 두개로 나눔!

__뒤에서부터 생각해서 문제를 풀수 있을까?__

문제에 내재된 순서를 바꿔 보는 것이다

A에서 B로 가는 방법을 찾기 어렵지만 B에서 A로 가는 방법을 찾기 쉬울때

__순서를 강제할 수 있을까?__

순서가 없는 문제에 순서를 강제해서 문제를 푸는 방법도 있다. 

__특정 형태의 답만을 고려할 수 있을까?__

순서를 강제하는 기법의 연장선으로 정규화 기법이 있다. 정규화란 우리가 고려해야 할 답들 중 형태가 다르지만 결과적으로 똑같은 것들을 그룹으로 묶은 뒤, 각 그룹의 대표들만 고려하는방법이다.

# 3장

## 3.1

알고리즘과 자료구조를 모두알기도힘들고, 특정 문제에서 쓰인다. 하지만 코딩은 모든 문제풀이에 쓰이므로 중요하다. 코드는 일기 쉬운 코드를 목표로 작성해야한다. 디버깅도 쉬워지고, 한번에 정확하게 작성하기 어렵기때문이다. 자신의 코드 스타일을 간결하고 일관되게 다듬으려고 노력해야한다. 

## 3.2 좋은 코드를 짜기 위한 원칙



### 간결한 코드 작성

가장 간결한 코드를 작성하자. 코드가 짧을수록 오타나 단순한 버그가 생길 우려가 줄어들고, 디버깅도 쉬워진다.

모든 부분은 일반적인 회사에서 잘 짠 코드와 같은 지향점을 가지고 있지만 프로그래밍 대회에서 더 좋은 도구도있다. 예를 들면 전역 변수의 광범위한 사용이다. 매크로를 사용(C++에 해당)

### 적극적으로 코드 재사용하기

코드를 모듈화 하자! 

같은 코드가 반복된다면 이들을 함수나 클래스로 분리해서 재사용하는 것이다. __같은 코드가 세 번 이상 등장한다면 항상 해당 코드를 함수로 분리해 재사용하는 것을 기본 윈칙으로하자__. 디버깅 시간도 엄청나게 줄어든다.

이상적인 세계에서는 한 함수가 두가지 이상의 일을 해서는 안된다고 말한다. 입력을 읽어들이는 함수, 입력을 처리하기 쉬운 형태로 바꾸는 함수, 실제 문제를 푸는 함수 각각 분리되어 있어야한다는 소리다. 하지만 대부분 프로그래밍 대회에서는 이정도로 엄격하게 안한다.

### 표준 라이브러리 공부하기

내가 배열, 큐, 스택, 리스트, 딕셔너리를 직접짜기보다는(이해는 필요), 표준 라이브러리를 사용하자.

### 항상 같은 형태로 프로그램을 작성하기

문제를 풀다보면 여러 종류의 코드를 반복적으로 짜게된다. 이분법, 그래프의 너비 우선 탐색,,,알고리즘, 자료구조등.. 매우 자주 작성하게된다

 for while문도 바꾸고, 크기 가로 순으로 전달하다가 가로, 세로 순으로 전달하고 코드작성할때마다 바뀔수도있다. 하지만 이는 디버깅에 불리하다. 한번 검증된 과정 코드가 있다면 작성하고 이것만 꾸준히 사용하자.

### 일관적이고 명명법 사용하기

사용하는 언어의 표준 라이브러리에서 사용하는 명명 규약을 익히자. 모호한 명명법은 때로 잡아내기 힘든 오류를 만들어낸다

```python
def judge(y,x,cy,cx,cr)
```

judge함수는 언제 `true` 를 반환할지모른다. 디버깅할때 힘들수도있다

```python
def isInsideCircle(y,x,cy,cx,cr)
```

이렇게 함수명을 정의한다면 점이 원안에 있을때 `ture`  를 반환한다고 알수있다.

### 모든 자료를 정규화해서 저장하기

같은 자료를 두 가지 형태로 저장하지 않는 것이 중요하다. 예를 들어 유리수를 표현하는 클래스(C++기준)을 작성한다고하면, 이때 입력받는 유리수를 항상 약분해 기약 분수로 표현하는 것이 좋다. 그렇지 않는 다면 9/6, 3/2를 표현하는 변수가 따로 존재하게된다. 

다른 예로는 시간은 UTC시간, 문자열을 다루는 프로그램은 외부에서 문자열을 읽어들이자마자 UTF-8 인코딩으로 변환해야만 문자열을 다루기 훨씬 편해진다.

__즉, 정규화는 프로그램이 외부에서 자료를 입력받거나 계산하자마자 곧장 이뤄저야한다.__ 

### 코드와 데이터를 분리하기

날짜를 다루는 프로그램을 작성하는데, 날짜를 출력할떄 월을 숫자가 아니라 영문 이름으로 출력해야한다하자.. 초보자는 12줄 짜리 if문을 써서 하겠지..

코드의 논리와 상관 없는 데이터는 가능한 부리하는 것이좋다. 각 월의 영어 이름을 다음과 같은 테이블로 만드는 것으로 해결가능하다.

```python
month_name = ["January", "Februray"....]

#다른예시로 체스 기사가 움직일수있는 상대좌표8가지
knight= [2,2,-2,-2,1,1,-1,-1]
```

### 자주하는 실수

__같은 실수를 반복하지말고, 실수에서 배우는 것이 좋고, 남의 실수로부터 배워 유사한 실수를 저지르지 않는것이 최고다__

자주하는 실수모음

__산술 오버플로__

실수를 계산 과정에서 변수의 표현 범위를 벗어나는 값을 사용하는것. (3.5참조)

__배열 범위 밖 원소에 접근__

배열 범위 밖의 원소에 접근하는 오류!

__일관되지 않은 범위 표현 방식 사용하기__

배열의 잘못된 위치를 참조하는 오류가 발생하는 큰 원인중 하나로, 프로그램 내에서 여러 가지의 범위 표현 방식을 섞어 쓰는 경우가 있다. 

예를 들면 1~12의 수의 범위를 나타낼때 닫힌 범위인 1<=x<=12를 사용하고 (공집합표현시 어려움), 열린범위는 0<x<13임을 잘 고려해야한다. (시작이 0일때는 -1로 써야하므로 어색해진다)

우리는 첫번째 시작하는 값은 포함하고 마지막 값은 포함하지 않게 쓰자

1<=x<13으로 쓰자!     Like `[1,13)`

`python의 range(x,y)` 범위는 x<=x<y와 같다. 

> __장점 3가지__
>
> - x,y를 같은 값으로 줄경우 공집합이 된다
> - 두 구간이 연속해 있는지 알기쉽다. range(a,b)와 range(c,d)가있을때 b=c 혹은  a=d인지만 확인하면된다.
> - 구간 크기를 쉽게 알수있다. b-a하면 자연수의 수가 된다

__off-by-one오류__

off-by-one 오류는 계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류들을 가리킨다. 예를들면 100미터인 담장에 10미터 간격으로 울타리 기둥을 세우면 필요한 기둥은 10개가 아니라 11개이다.

이런 오류는 < > <= >=를 생각하지 않고 풀었기 때문이다. 따라서 실수를 방지하려면 최소 입력이 주어졌을 때 이 코드가 어떻게 동작할지 되새겨 보는것이다.

답장의 길기아 0미터라도 기둥하나는 박아야되는것처럼!

__컴파일러가 잡아주지 못하는 상수 오타__

변수명이나 함수명에서 낸 오타는 컴파일러가 잡아주지만, 각종 사수를 잘못 입력해서 내는 오답 처리는 쉽게 잡아내기 힘들다. 

> - 반드시 코드와 데이터를 분리하자. 데이터를 별도 상수 배열에 저장도 마찬가지이다.
> - weird로 출력해야하는것을 wierd로 출력하는 것도 결국 실력이다. 소문자 대문자도 많이 틀린다
> - 데이터에서의 0의 갯수 틀림
> - (C++기준)64비트 정수형으로 들어야할것들을 64비트라고 저장하지않고, 기본 32비트로 저장...

__스택 오버플로__

프로그램의 실행 중 콜 스택이 오버플로해서 프로그램이 강제종료되는 것 또한 흔히 하는 실수다. (C++)에선 지역 변수로 선언한 배열이나 클래스 인스턴스가 기본적으로 스택 메모리를 사용하기때문.

__다차원 배열 인덱스 순서 바꿔 쓰기__

평소에 2차원 이상의 다차원 배열을 사용할 일이 많지 않지만, 가끔 대회에서 4,5차원의 고차원 배열 쓰게된다. 이때는 실수를 줄이기위해 가능한 한 특정 배열에 접근하는 위치를 하나로 통일 하는 것이 좋다

__잘못된 비교 함수 작성__

정수의 집합들을 다루는 프로그램에 정수의 집합을 저장하는 `intergerSet` 클래스가 있다고하자.   프로그램안에 `vecter<intergerSet>` 에 담긴 집합들을 순서대로 처리하는 것인데, 집합 A가 B의 진부분집합이라면 A는 항상 B보다 먼저 처리되어야합니다. 따라서 `intergerSet` 의 배열을 정렬하려고 한다. 사용자가 작성한 클래스를 정렬할 떄는 정렬 함수에 비교 함수를 전달하거나, 연산자 오버로딩을 이용해 < 연산을 오버로딩해야된다. 

![스크린샷 2020-11-04 오후 12.02.32](https://tva1.sinaimg.cn/large/0081Kckwgy1gkcyl2v99tj313k0n2e81.jpg)

> **오버로딩(Overloading)** : 같은 이름의 메서드 여러개를 가지면서 매개변수의 유형과 개수가 다르게하여 다양한 유형의 호출에 응답할수있게하는것
>
> **오버라이딩(Overriding)** : 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의해서 사용, 재정의는 즉 ,부모클래스의 메서드는 무시하고, 자식 클래스의 메서드 기능을 사용하겠다는 것

위에 3.1코드에서 잘못짠것은 바로 operator <의 오버로딩이다. C++의 표준 라이브러리가 예상하는 일관된 답을 코드3.1 이 반환하지 않아서 문제가된다. 

![스크린샷 2020-11-04 오후 12.29.12](https://tva1.sinaimg.cn/large/0081Kckwgy1gkczcqg9oij315c0kk7wh.jpg)

특히 코드3.1에 대해서는 표준 라이브러리의 < 오퍼레이터의 4. 규칙에 맞지않는다. 예를 들면 {1},{2},{2,3} 이 있다면 코드 3.1에 대해서 {2}<{2,3}만 참이고 나머지는 모두거짓이다. 하지만 4번 규칙에 의해 a<b,b>a가 모두 성립하면 a=b라는 것으로 인지하므로 {1}={2}, {1}={2,3}이다. 따라서 {1}={2}={2,3}으로 판단하고 {2}<{2,3}으로 판단되므로 세 원로를 정렬할수없다.

올바른 비교함수 작성을 위한 방법은 a,b가 완전히 같은 경우를 제외하고는 어느 때도 두 집합이 같다고 판단하지 않는것이다. 이를 위해 우리가 원하는 포함 관계가 성립되지 않는 두 집합에 대해서도 어떤 별도의 순서를 정해줘야한다. 

특히, 이 별도의 순서는 우리가 원래 정하려 했던 순서와 모순이 되어선 안된다. 예시로 {1,3},{3},{2}가 주어진다면 사전순으로는 {1,3},{2},{3}이지만 포함관계로는 {3},{1,3}순으로 되어야한다. __서로 모순된다__

a와 b의 크기(집합크기)를 비교하여 같을때만 사전순으로 비교하면 된다. 

![스크린샷 2020-11-04 오후 12.48.35](https://tva1.sinaimg.cn/large/0081Kckwgy1gkczwwriqwj31180n4b29.jpg)

__최소, 최대 예외 잘못 다루기__

예외란 우리가 예상한 입력의 규칙에 들어맞지 않는 모든 입력이다. 이는 너무 광범위하므로 자주실수하면 예외를 보자면, 바로 가장 작은 입력과 가장 큰 입력에 대해 제대로 동작할지를 생각해 보면 오류를 잡을 수 있는 경우가 많다.

![스크린샷 2020-11-04 오후 12.52.30](https://tva1.sinaimg.cn/large/0081Kckwgy1gkd00zsueaj318a0myb29.jpg)

여기서 잘못된부분 두가지는 작은 소수 2를 판단못하는것과 1도 true로 출력됨으로 잘못된것을 알수있다.

__연산자 우선순위 잘못 쓰기__

사칙연산의 우선순위를 잘알고 의도된 대로 동작핟도록 코드를 짜자

```python
b =0
if (b and 1 ==0):
    print("실행됨")
```

얼핏보면 b=0일때 실행될것같지만 실제로는 비교연산자(==)보다 and 논리연산자의 우선순위가 낮다.

```python
b =0
if (b and (1 ==0):
    print("실행됨")
```

이것과 같다, 결과적으로 조건문은 항상 거짓이다.

▼ **표 47-3** 파이썬 연산자 우선순위

| 우선순위 | 연산자                                          | 설명                                                 |
| -------- | ----------------------------------------------- | ---------------------------------------------------- |
| 1        | (값...), [값...], {키: 값...}, {값...}          | 튜플, 리스트, 딕셔너리, 세트 생성                    |
| 2        | x[인덱스], x[인덱스:인덱스], x(인수...), x.속성 | 리스트(튜플) 첨자, 슬라이싱, 함수 호출, 속성 참조    |
| 3        | await x                                         | await 표현식                                         |
| 4        | **                                              | 거듭제곱                                             |
| 5        | +x, -x, ~x                                      | 단항 덧셈(양의 부호), 단항 뺄셈(음의 부호), 비트 NOT |
| 6        | *, @, /, //, %                                  | 곱셈, 행렬 곱셈, 나눗셈, 버림 나눗셈, 나머지         |
| 7        | +, -                                            | 덧셈, 뺄셈                                           |
| 8        | <<, >>                                          | 비트 시프트                                          |
| 9        | &                                               | 비트 AND                                             |
| 10       | ^                                               | 비트 XOR                                             |
| 11       | \|                                              | 비트 OR                                              |
| 12       | in, not in, is, is not, <, <=, >, >=, !=, ==    | 포함 연산자, 객체 비교 연산자, 비교 연산자           |
| 13       | not x                                           | 논리 NOT                                             |
| 14       | and                                             | 논리 AND                                             |
| 15       | or                                              | 논리 OR                                              |
| 16       | if else                                         | 조건부 표현식                                        |
| 17       | lambda                                          | 람다 표현식                                          |

햇갈리면 괄호로 감싸서 계산하자

> 비트 연산자는 비트(bit) 단위로 논리 연산을 할 때 사용하는 연산자입니다. 또한, 비트 단위로 전체 비트를 왼쪽이나 오른쪽으로 이동시킬 때도 사용합니다.
>
> ```python
> a = 1
> b = 3
> print(a^b)
> 
> >>>
> 2
> ```
>
> 이진법 0,1로 생각해보면 a는 0,1 b는 1,1이므로 xor결과 1,0나온다. 따라서 2가 출력됨.

__너무 느린 입출력 방식 선택__

대부분의 프로그래밍 언어에서는 텍스트를 입출력할 수 있는 다양한 방법을 제공한다. 예를 들어 C++에서는 gets()를 이용해 모든 입력을 문자열 하나로 파싱할 수도있고, cin등의 고수준 입력 방식을 사용할 수도있지만, 고수준은 속도 저하..

__위에 사례처럼 입력출력할 변수가 1만개 넘어가면, 긴장하고 python에서 어떤 입출력이 빠르게 되는지 점검하자__

__변수 초기화 문제__

프로그램을 한번만 실행하고, 한 번에 여러개의 입력에 대해 답을 처리하라고요구한다. 이때 이전 입력에서 사용한 전역 변수 값을 __초기화하지 않고 그대로 사용하면 절대 안된다__

이를 방지하기위해 동일 예제 두번반복시키면 혹여나 못찾아낸것도 찾을수있다.

### 디버깅과 테스팅

__디버깅에 관하여__

대부분 사람들은 예제 입력 실행후 결과가 다른 상황이면 보통 디버거를 켜고 프로그램이 실행되는 과정을 하나하나 따라가본다. 하지만 대회에서는 눈으로하는것이 빠를때도있으며, 재귀호출 중복 반복문을 많이 사용하는 복잡한 코드는 디버거 활용이 적당하지않고, 3명이 컴퓨터 1개이기때문에 나머지 2명 아무것도못함. 따라서 복잡한 코드를 짜지 말고, 잘 분리된 기능적인 코드를 짜야한다.

눈으로 디버깅 가능한 조건은 단순한 코드+ 분리된 기능적 코드 이다

__눈으로 디버깅할 때 순서__

- 작은 입력에 대해 제대로 실행되나 확인 > 예제 입력의 크기를 줄여 디버깅

- python의 `assert` 함수를 사용해 체크하자. 참이면 무시되며, 거짓일때 오류를 냄

  예를 들면 함수에서 넘겨받은 인자들이 범위안에 있는지, 값들은 제대로 입력받았는지 검사가능

- 프로그램의 계산 중간 결과를 출력한다> 어디까지 예상대로 진행됫는지 보기위해

__앞으로 디버깅시 눈으로 위 3과정을 거치고도 모르겠다면 디버거를 사용하자.__

__테스트에 관하여__

답안 제출 전에 예제 입력을 만들어 가능한 많이 프로그램을 테스트하는 것이 좋다. 예제를 변경하여 가장 작은 입력, 가장 큰 입력을 만들어서도 넣어보고, 시간안에 실행되는지, 답이 잘 나오는지 꼭 테스트해보자! 

프로그램을 테스트할 때 유용하게 사용할 수 있는 기법으로 스캐폴딩(공사판에 걸어다니기위한 임시 구조물..)이 있다. 이 말은 다른 코드를 개발할 때 뼈대를 잡기 위해 임시로 사용하는 코드라는 뜻으로 쓰입니다.

스캐폴딩은 코드의 정당성을 확인하거나 반례를 찾는데 특히 유용하게 쓰인다.

예를 들면 코드를 제출했는데 오답판정이 나는데, 예제는 다 통과하는 상황이라면 오류를 찾는게 쉽지않다. 이때 임의의 작은 입력을 자동으로 생성해 프로그램을 동려 보고, 그 답안을 검증하는 프로그램을 짜면된다. 직접 작성한 정렬 함수를 테스트 하고 싶다면 `while Ture`안에서 입력값을 매번생산해서 함수에 넣어주고 하나는 직접만든 함수에 하나는 표준 라이브러리sort를 이용해 결과값이 다르다면 오류를 내고 원인을 출력하게한다.

하지만 비교 대상이없다면, 아주 단순한 알고리즘으로짠(대신느린)것과 비교해볼수도있다. 

__꼭 필요한 경우에 쓰자. 시간을 그만큼 더 잡아 먹기 때문이다__

### 변수 범위의 이해

__산술 오버플로__

어떤 식의 계산 값이 반환되는 자료형의 표현 가능한 범위를 벗어나는 경우를 말한다

수학에 어떤 변수 n있다면 이 변수에 담을 수 있는 숫자제한없다. 하지만 컴퓨터의 모든 변수에는 담을 수 있 크기가 제한되어있다. 즉, 완전히 정당한 알고리즘도 구현했을때 흔히 문제를 일으키는 것이 산술 오버플로다.

__실수 2가지__

- 보통 언어에서는 오버플로 일어나도 경고안해줌. 비효율적이니까
- 프로그램의 정당성을 검증할 때 프로그램 논리의 정확성에만 집중하다보면 산술 오버플로가 등장할 것이라는것을 간과할때가 많다

__너무 큰 결과__

32비트, 64비트 고려하기

__너무 큰 중간 값__

출력 값은 작지만, 중간 과정에서 큰 값을 일시적으로 계산해야할때!(64비트, 32비트고려)

__너무 큰 무한대 값__

너무큰 무한대 값들이 서로 연산되면 산술 오버플로가 발생하므로 조심하자

__오버플로 피해가기__

더 큰 자료형을 쓰면 오버플로를 피할수있다. 64비트 사용!

또한 연산 순서를 바꾼다면 해결될수도있다

~~__자료형의 프로모션__~~

~~사칙연산이나 대소 비교등의 이항 연산자들은 두 개의 피연산자를 받는다. 피연산자의 자료형이 다르거나 자료형의 범위가 너무 작은 경우 컴파일러들이 대개 이들을 같은 자료현으로 변환하여 계산하는데 이를 프로모션이라고함(C++해당내용) 버그에 기여할때가있다.~~



