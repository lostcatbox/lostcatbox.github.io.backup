---
title: OS에 관한 쉬운 세가지 이야기
date: 2020-08-26 13:59:33
categories: [OS]
tags: [OS, Basic]
---

# 왜?

근본적으로 전공자와 비전공자의 차이를 매꾸기 위한 목적이다

[자료](http://pages.cs.wisc.edu/~remzi/OSTEP/)에서 제공하는 운영체제, 3가지 쉬운 이야기에 대해  볼수있다.

- 가상화(Virtualization)
- 동시성(Concurrency) 
- 지속성(Persistence)

이러한 아이디어를 배울있어서 OS의 구조, 즉 CPU에서 어떻게 프로그램을 다음 실행하거나 어떻게 가상 메모리 시스템의 메모리 과부하를 처리하거나 가상 머신 모니터의 작동 방식 디스크에 대한 정보를 관리하는 방법도 약간은 있지만 부품이 고장 났을 때 동작하는 분산 시스템을 구축하는 방법에 대해 설명합니다. 구체적으로 말하면 그러한 같은 것이군요.

일단 2020.09.07까지 읽어왔던것을 정리할 것이다. 책은 기본적으로 virtualization, concurrency까지 읽었고, 100% 이해했다곤 하지못하겠지만, 컴공 친구말로는 이정도면 컴공에서 OS지식수준은 도달했고, 조금더 아는 수준으로 알아도된다고 하여 멈추고 다른 공부로 전환하려고한다.

필자의 이 포스팅은 남을 이해시키기 위함이 아닌 내가 이해하면서 끄적이면서 정리한 글이라고 봐주면 고맙겠다.

__제1장 이 책에 관한 대화__
__제2장 운영체제 개요__

프로그램은 매우 단순한일을 한다.

초당 수백만 번 명령어를 반입(fetch)하고 해석(decode)하고 (즉, 무슨 명령어인지 파악하고), 실행(execute)한다.

(즉, 두수를 더하고, 메모리에 접근하고, 조건을 검사하고, 함수로 분기하는 등의 정해진 일을 한다.)

명령어 작업을 완료한 후 프로세서는 다음 명령어로, 또 그 다음 명령어로 프로그램이 완전히 종료될 떄까지 실행한다.

__운영체제란__

프로그램을 쉽게 실행하고(동시에 여러 개의 프로그램을 실행할수도), 프로그램 간의 메모리 공유를 가능케 하고, 장치와 상호작용을 가능케하고, 다양한 흥미로운 일을 할수있게하는 소프트웨어이다. 시스템을 사용하기 편리하게, 정확하고, 올바르게 동작 시킬 책임이있다.

![IMG_43F69D48D405-1](https://tva1.sinaimg.cn/large/007S8ZIlgy1ginp9x5nufj316y0u07wh.jpg)

운영체제는 다양한 물리자원들을 배분하기 위해 __가상화__를 한다. 그래서 OS를 가상 머신이라고 부른다.

사용자 프로그램의 프로그램 실행, 메모리 할당, 파일 접근과 같은 가상 머신과 관련된 기능들을 운영체제에게 요청할 수 있도록, 운영체제는 사용자에게 API를 제공한다.__(시스템콜)__

가상화는 많은 프로그램들이 CPU를 공유하여, 동시에 실행될 수 있게한다. 프로그램들이 각자 명령어와 데이터를 접근할수있게한다. OS는 자원 관리자

 물리적인 CPU, 메모리, 디스크는 시스템의 자원이다.

효율적으로, 공정하게, 이들 자원을 관리하는 것이 OS의 역할이다.

만약 두개의 쓰레드를 사용하여 각자 같은 변수를 참조하여 100을 더하는 프로그램을 실행시킨다면 결과는 200이 아닌 1xx가 나올것이다.

이뉴는 명령어가 한번에 하나씩만 실행된다는 것과 관련있다.

변수를 메모리에서 레지스터로 탑재하는 명령어1

레지스터를 1증가시키는 명령어 2

레지스터의 값을 다시 메모리에 저장하는 명령어 3

하지만 3개의 명령어가 원자적으로 (한번에 3개 모두) 실행되지 않기 때문에 이상한일이 발생한다.

__병행성__ 과 관련있다

# 제Ⅰ편 가상화

## 제3장 가상화에 관한 대화

복숭아(CPU) 나눠먹기



## 제4장 프로세스의 개념

 프로세스= 실행중인 프로그램

프로그램 자체는 생명x, 디스크상에 존재하며, 실행을 위한 명령어와 정적 데이터의 묶음이다. 

프로세스들이 생각할때 각자 자신의 CPU가 있다고 착각하게 할수있을까?

Time Sharing기법으로 하나의 프로레스를 실행하고, 얼마 후 중단시키고 다른 프로레스를 실행하는 작업 반복 (context switch의 구현필요)

policy는 어느 프로그램을 실행시킬것인가?에 대한 대답이다 

mechanism은 어떻게 다음 실행할 프로그램들로 넘어갈것인가?에 대한 대답이다

__프로그램에서 프로세스 생성__

- OS가 프로그램 코드와 정적데이터를 메모리, 프로레스의 주소 공간(address space)에 탑재(load)하는 것이다.

- 스택, 힙을 할당한다

  (스택은 지역 변수, 함수 인자, 리턴 주소등을 저장,힙은 동적으로 할당된 데이터를 저장위해서 연결 리스트, 해시 테이블, 트리 크기가 가변적인 자료 구조위해서)

- OS는 입출력과 관계된 초기화 작업을 수행한다.

- OS는 CPU를 새로 생성된 프로세스에 넘기게 되고 프로그램이 실행된다.

__프로세스 상태__

![IMG_1548](https://tva1.sinaimg.cn/large/007S8ZIlgy1ginq8ylq3oj316y0u01kx.jpg)

ready상태에서 스케줄되어야함 그래야 running상태가능

running상태는 현재 실행중인 프로세스임

I/O기다리거나 이벤트 wait를 받았을때 waiting상태로 전환!

__자료구조__

프로세스 리스트라는 자료 구조를 이용하여 시스템에서 실행 중인 프로그램을 관리한다. 프로세스의 관리를 위한 정보를 저장하는 자료 구조를 프로세스 제어 블럭(PCB)라고 부른다. 

레지스터 문맥(register context)자료 구조는 프로세스가 중단되었을 때 해당 프로세스의 레지스터값들을 저장한다. 이 레지스터값들을 복원하여  OS는 프로세스 실행을 재개한다(문맥 교환(context switch))

## 제5장 막간: 프로레스 API

fork() 시스템콜

PID(프로세스 식별자)

__자식 프로세스는 부모 프로세스와 완전히 동일하지는 않다. 자식 프로세스는 자신의 주소 공간, 자신의 레지스터, 자신의 PC값을 갖는다.__

CPU스케줄러는 실행할 프로세스를 선택한다. 어느 프로세스가 먼저 실행될지 모름.

wait() 시스템콜

부모가 먼지 실행되면  wait()가 일어나서 자식 프로세스가 일끝낼떄까지 리턴하지않는다.



exec() 시스템콜

자신이 아닌 다른 프로그램을 실행해야 할떄 사용한다. (fork()는 자신의 복사본을 만드는 것과 반대)

fork()와 exec()를 나눠놓은이유는 fork()하고 명령어 (예를들면 입출력바꿈등의 명령)후에  exec()를 하여 외부 프로그램 실행할 수 있기 때문이다





## 제6장 제한적 직접 실행 원리

__CPU시간을 나눠 씀으로써 가상화를 구현한다.__(Time sharing)

성능저하, 제어권의 문제가 발생할수있다.

직접 실행 원리로 프로그램을 CPU에서 직접 실행시킴.

제한적! 이라는것은 프로그램 실행에 제한을 둬야 OS는 제어권을 다시 획득해서 제어를 할수있다.

OS에 사용자 모드와 커널 모드가 도입되었다

사용자 모드에서 실행되는 코드는 할수있는 일이 제한된다. 프로세스가 제한된 요청을 할 경우 프로세서가 예외를 발생시키고, OS는 해당 프로세스를 제거한다

커널 모드는 OS의 중용한 코드들이 실행된다. 이 모드에서 실행되는 코드는 모든 특수한 명령어를 포함하여 원하는 모든 작업을 수행할 수 있다.

사용자 프로세스에게 특권 명령을 실행해야할때는 OS가 제공하는 시스템 콜을 이용한다.

trap 특수 명령어를 실행> 커널 안에서 분기하는 동시에 커널 모드로 상향 조정> 커널 모드 진입후 해당 명령 실행> 완료시 return-from-trap 특수 명령어 호출> 사용자 모드로 다시 하향 조정> 호출한 사용자 프로그램으로 리털

trap요청한 프로세스의 레지스터들을 저장해야한다. return-from-trap 명령어 실행 시 사용자 프로세스로 제대로 리턴할 수 있도록 하기 위함이다.

커널은 부팅 시에 trap table만들고 시스템을 통제한다. trap handler는 트랩 발생시 해야하는 행동들이 적혀있다. 즉 하드웨어들이 예외적인 사건이 일어났을때 trap>trap handler>순으로 진행 (???)

프로레스간의 전환중 OS가 제어권획득을 위한 방법은 timer interrupt를 발생시키는것이다. 즉 수행 중인 프로세스가 중단되고 미리 구성된 OS의 interrupt handler가 실행된다. 이 시점에서 OS는 CPU제어권을 다시 얻게 되고 원하는 일가능(현재 프로세스를 중단하고 다른 프로세스를 실행시키는 작업등...)

OS가 현재 실행중인 프로세스를 재개할것인지, 다른 프로세스로 전활할 것인지를 결정해야한다. 

이 역할을 OS의 scheduler라는 부분에 의해 내려진다.

다른 프로세스로 전활하기로 결정되면 OS는 context switch한다.(코드를 실행)

현재 실행중인 프로세스의 레지스터 값을 커널 스택 같은 곳에 저장하고 곧 실행될 프로세스의 커널 스택으로부터 레지스터 값을 복원하는 것이 전부다.

시스템 콜을 처리하는 도중 타이머인터럽트가 발생? 등의 질문은 __병행성__단원에서...



## 제7장 스케줄링: 개요

(프로세스를 7~9까지 job이라고 부를것임)

스케줄링 평가 항목.

![스크린샷 2020-09-13 오후 2.21.08](https://tva1.sinaimg.cn/large/007S8ZIlgy1gioyd8lqa4j313g0fm41y.jpg)

### FIFO(First In, First Out)

먼저 온 job 먼저 처리

A job 이 엄청 길고 B, C job이 짧다고 가정

맨 처음 온 job이 너무 많은 시간요구하면 뒤에 다른 job들의 결과처리까지 시간너무 많이소요

### SJF(Shortest Job First)

가장 짫은것 처리하기

A가 먼저 도착해버리고 일 처리가 된다면

B,C가 늦게 도착하면 FIFO에서의 문제점과 같아짐

### STCF(Shortest Time-to-Completion First)

Preemptive scheduling 선점방식!

can stop a job! 이 필요하며, 즉,context switch를 필요로 한다.

A 도착후 10초후에 B,C가 도착하면

B,C가 먼저 처리가능한 job이므로 A를 중단후 B,C처리후 A로 다시 CPU줌

### RR(Round-robin)

 job을 시간으로 나눠서 배치함 (time slice)

time quantum 조건에 따라

- small일 경우

  good responsiveness, high context switch overhead(계속 바꿔야하므로 스위치 비용높다)

- Large일 경우

  low context switch overhead but bad responsiveness

### Incorporating I/O

많은 애플리케이션이 I/O를 한다.

A가 I/O요청하면 잠시  block 하고 B처리하다가 I/O요청 받으면 A로 스위칭





## 제8장 스케줄링: 멀티 레벨 피드백 큐

### MLFQ(Multi-Level Feedback Queue)

SJF, STCF: good for turnaround time, terrible for response time

RR: vice response time

How to optimize the turnaround time while minimizing response time?

__MLFQ (Multi-Level Feedback Queue)__

- Consist of multiple queues
- Each queue is assigned a different priority level
-  A job that is ready to run is on a single queue (running or blocked jobs are out of the queues)
- A job with higher priority (a job on a higher queue) is chosen to run next (RR among jobs in the same queue)

![스크린샷 2020-09-13 오후 2.43.52](https://tva1.sinaimg.cn/large/007S8ZIlgy1gioz0tb85sj30sc0380uz.jpg)

![스크린샷 2020-09-13 오후 2.43.59](https://tva1.sinaimg.cn/large/007S8ZIlgy1gioz0xp3rlj30y609eqbc.jpg)

![스크린샷 2020-09-13 오후 2.44.58](https://tva1.sinaimg.cn/large/007S8ZIlgy1gioz1yxunyj314i0dmdj2.jpg)

![스크린샷 2020-09-13 오후 2.45.42](https://tva1.sinaimg.cn/large/007S8ZIlgy1gioz2q97axj31280o2tk0.jpg)



## 제9장 스케줄링: 비례 배분







## 제10장 멀티프로세서 스케줄링(고급)

![스크린샷 2020-09-13 오후 2.47.56](https://tva1.sinaimg.cn/large/007S8ZIlgy1gioz523csyj312r0u0q8a.jpg)

![스크린샷 2020-09-13 오후 2.48.08](https://tva1.sinaimg.cn/large/007S8ZIlgy1gioz59mo5pj311i0u00yb.jpg)

![스크린샷 2020-09-13 오후 2.49.44](https://tva1.sinaimg.cn/large/007S8ZIlgy1gioz6xlvm1j313c0u0dnx.jpg)



![스크린샷 2020-09-13 오후 2.48.53](https://tva1.sinaimg.cn/large/007S8ZIlgy1gioz69csnwj314d0u0q9q.jpg)

## 제11장 CPU 가상화에 관한 마무리 대화

__Mechanism__: Context switch, Timer interrupt, Handler > 어떻게 넘어가고 처리할것인가!!에 대한것 메커니즘

__Policy__: FIFO, SJF, RR, MLFQ, Lottery, Stride, Multiprocessor > 일 나열에 관한 정책

 

## 제12장 메모리 가상화에 관한 대화

__사용자 프로그램이 생성하는 모든 주소는 가상주소다.__

__즉, 당신이 보는 모든 것은 가상 주소__

왜 물리 메모리를 가상화해?

OS는 각 프로세스에게 단지 환상을 제공한다. 마치 자기만의 메모리가 있는것처럼!

OS가 하드웨어로부터 약간의 도움을 얻어 가장된 가상 주소를 실제 물리 주소로 변환하고 원하는 정보의 위치를 찾을수있다. 사용하기 쉬운 시스템

고림과 보호!도 중요한 이유중하나

## 제13장 주소 공간의 개념

멀티프로그래밍과 시분할이 필요해졌다. 시분할을 구현하는 한 가지 방법은 실행 중단 다른 프로세스 실행 중단하는 것이다. 이 중단 시점에 모든 상태를 디스크에 저장..다른 프로세스해당하는거 메모리 올리는것은 매우 느리다

즉, 레지스터 상태를 저장하고 복원하는 것은 빠르지만, 프로세스 전환시 프로세스를 메모리에 그대로 유지하면서, 운영체제가 시분할 시스템을 효율적으로 구현할 수 있게 하는 것이다.

여기서 발생하는 문제점은 여러 프로그램이 메모리에 동시에 존재하려면 __보호__가 중요한 문제다. 한 프로세스가 다른 프로세스의 메모리를 읽는것을 막아야한다

__주소 공간__

OS는 사용하기 쉬운 메모리 개념을 만들어야하고, 이 개념이 주소 공간이다.

주소 공간은 실행 프로그램의 모든 메모리 상태를 갖고 있다. 

일단 실행중인 프로그램 코드(명령어)는 반드시 메모리에 존재하므로 주소 공간에 존재한다. 스택은 함수 호출 체인 상의 현재 위치, 지역 변수, 함수 인자와 반환 값등을 저장하는 데 사용된다. 힙은 동적으로 할당되는 메모리를 위해 사용된다.  힙과 스택은 각각 반대방향으로 커진다.![스크린샷 2020-09-14 오후 4.33.51](/Users/lostcatbox/Library/Application Support/typora-user-images/스크린샷 2020-09-14 오후 4.33.51.png)

주소 공간을 설명할떄, OS가 실행중인 프로그램에게 제공하는 개념을 설명한다. 실제로 프로그램이 물리 주소 0~16KB사이에 존재하는 것이 아니다. 실제로는  임의의 물리 주소에 탑제된다.!!!

OS가 메모리를 가상화하여 다수의 프로세스에게 프로세스전용의 커다랑 주소 공간이라는 개념을 제공한다.

프로세스 A가 가상주소 0부터 load를 수행할때, OS는 하드웨어의 지원을 통해 물리 주소 0이 아니라 물리 주소 320KB(A가 탑재된 메모리 시작주소)를 읽도록 보장한다.

VM(가상 메모리 시스템)의 목표는

- 투명성(실행중인 프로그램이 가상 메모리의 존재를 인지x)
- 효율성(가상화가 시간, 공간 측면에서 효율적이도록)(TLB지원,,)
- 보호(프로세스가 남의 프로세스 메모리에 접근, 영향 x)>>프로세스들 서로 고립



## 제14장 막간: 메모리 관리 API

어떻게 메모리를 할당하고 관리할 것인가?

C프로그램 실행되면, 두가지 유형의 메모리 공간이 할당된다

스택 메모리는 컴파일러에 의해 암묵적.. 자동 메모리임

함수 리턴 이후에도 유지되어야 하는 정보는 스택에 저장x

힙 메모리는 모든 할당과 반환이 프로그래머에 의해 명시적으로 처리됨

__malloc()__ 힙에 요청할 공간의 크기 넣어줌., 메모리 할당

__free()__ 할당된 메모리 해제.

새로운 언어들이 자동 메모리 관리를 지원(가비지 컬렉터.)

...CS관련아니므로나머지패스



## 제15장 주소 변환의 원리

CPU가상화 부분에서 제한적 직접 실행이라는 기법을 집중적으로 다뤘다.

즉, 중요한 순간에 OS가 관여하여 하드웨어를 직접 제어한다.

메모리 가상화도 비슷한 전략이다.

하드웨어-기반 주소 변환 >> 주소 변환 으로 부른다

프로그램의 모든 메모리 참조는 가상 주소를 물리 주소로 변환한다.

아주 예전에는 베이스와 바운드라는 간단한 아이디어가 채택되었다. (동적 재배치)

CPU마다 2개의 하드웨어 레지스터가 필요하다. 하나는 베이스 레지스터, 하나는 바운드 레지스터(=리미트 레지스터)이다.

프로그램 시작시 OS가 베이스 레지스터에 프로그램이 탑재될 물리 메모리 위치 시작주소를 저장한다. 프로그램 카운터(PC)는 128이라면 이를 베이스값을 더해서 해당 물리 주소로 변환됫으니 명령어를 가져온다. 또 프로세스에서 가상 주소 15KB의 값을 탑재하라는 명령어를 내리면, 이 주소를 프로세서가 받아 다시 베이스 레지스터 값(32KB라고가정)을 더하고 물리주소는 47KB에서 원하는 내용을 탑재한다.

이를 주소 변환 기술이라고 한다. 하드웨어는 프로세스가 참조하는 가상 주소를 받아들여 데이터가 실제로 존재하는 물리 주소로 변환한다. 동적 재배치! 프로세스가 실행을 시작한 이후에도 주소 공간을 이동가능하기때문에

리미트 레지스터는 합법적인 주소 참조의 범위에 있다는 것을 확인할때 쓰인다

베이스와 리미트 레지스터는 CPU칩 상에 존자하는 하드웨어 구조이다. 주소 변환에 도움을 주는 프로세서의 일부를  MMU라고 부르기도한다

주소 공간의 마지막 물리 주소를 리미트 레지스터에 저장해놓는다면

가상주소+베이스 =< 리미트 를 검사하면 유효한 범위인지 할수있다.

하드웨어는 베이스와 바운드 레지스터를 자체적으로 제공한다. 

CPU는 사용자 프로그램이 바운드를 벗어난 주소를 불법적인 메모리 접근을 시도하려고할때 예외를 발생시킬수있다. OS의 "바운드 벗어남"예외 핸들러가 실행되도록 조치.

context switch 가 일어날때 PCB(프로세스 제어 블럭)으로 OS가 실행중인 프로세스를 중단시키면 베이스와 바운드 레지스터의 값을 저장.(메모리에 저장해놓음)

동적 재배치는 비효율적이다.

주소 공간 이미지에서의  free는 즉 내부 단편화를 의미하는 것이므로..

이를 세그멘테이션!으로 줄일수있다.



## 제16장 세그멘테이션

베이스와 바운드 레지스터를 사용하면 OS가 물리 메모리의 다른 부분으로 쉽게 재배치할수 있다. 하지만 스택과 힙사이에 큰 free공간이 있으므로 그만큼 내부 단편화가 존재하게된다(낭비)

이를 위해 세그멘테이션이라는 아이디어가 탄생했다. MMU안에 오직 하나의 베이스와 바운드 쌍만 존재하는 것이 아니라 __주소 공간의 논리적인 세그멘트(segment) 마다 베이스와 바운드 쌍이 존재한다. __ 세그멘트는 특정 길이를 가지는 연속적인 주소 공간이다. 예시기준으로는 코드, 스택, 힙의 세 종류의 논리적 세그멘트가 있다.  OS는 각 세그멘트를 물리 메모리의 각기 다른 위치에 배치가능.

![스크린샷 2020-09-15 오후 12.41.09](https://tva1.sinaimg.cn/large/007S8ZIlgy1gir6pri3wsj30ei0i6aoi.jpg)

예시기준으로는 3쌍의 베이스와 바운드 레지스터 쌍이 필요하다. 오프셋값+베이스값 이 바운드값을 넘지 않으면 범위내에 있으므로 그 물리 메모리 주소를 읽는다.

> 가상 주소에서 각 논리에 해당하는 시작값을 뺴고, __오프셋값을 얻어낸후__ 다시 해당 베이스값을 더해야하는 것에 주의하자

__세그멘트 종류의 파악__

하드웨어는 가상 주소가 어느 세그멘트를 참조하는지, 그 세그멘트 안에서 오프셋이 얼마인지를 어떻게 알수있을까?

![스크린샷 2020-09-15 오후 1.36.39](https://tva1.sinaimg.cn/large/007S8ZIlgy1gir8bhzu55j31480hc1kx.jpg)

이런식으로 세그먼트를 명시하고, 나머지는 오프셋을 뜻하는것으로 해결한다. 특히 오프셋이 바운드보다 작은지 여부만 검사하면 된다.

시스템이 각 주소 공간 구성 요소(힙, 스택, 코드)를 (베이스, 바운드를 기준으로) 별도로 물리 메모리에 재배치하기 때문에 메모리 절약이가능하다.

문제점들은 다음과 같다 

- context switch때 세그멘트 레지스터의 저장과 복원이다

- 미사용중인 물리 메모리 공간의 관리다. 새로운 주소 공간이 생성되면 OS는 이 공간의 세그멘트를 위한 비어있는 물리 메모리 영역을 찾을 수 있어야한다. 각 세그먼트의 크기가 다를수있다.. 특 외부 단편화가 일어날수있다.

  ![스크린샷 2020-09-15 오후 1.45.27](https://tva1.sinaimg.cn/large/007S8ZIlgy1gir8kojnxej30ni0funij.jpg) 물리메모리상태이다

## 제17장 빈 공간 관리

외부 단편화를 방지하는 방법에 대해 생각해보기

__저수준 기법들__

분할 -  free list를 작성해놓고 할당 요청들어오면 split해서 free list update하고

병합 - 메모리 청크가 반환될때(free()사용시) 해제되는 청크의 주소와 바로 인접한 빈 청크의 주소를 살펴보고, 바로 인접해있다면 더 큰 빈 청크로 병합한다. 아래 그림 5번째

![IMG_920CBC59B6E0-1](https://tva1.sinaimg.cn/large/007S8ZIlgy1gir97tcj57j31ac0ruajg.jpg)

## 제18장 페이징: 개요

세그멘테이션은 가변 크기의 조각들로 분할하는 것이다. 공간을 다양한 크기의 청크로 분할할 때 공간 자체가 단편화가 될수있다. 할당은 점점더 어려워진다

이를 해결하기 위해 공간을 동일 크기의 조각으로 분할 하는 것을 고려한다

__페이징__

![IMG_B04CB3E0407E-1](/Users/lostcatbox/Downloads/IMG_B04CB3E0407E-1.jpeg)

프로세스의 주소 공간을 몇개의 가변 크기의 논리 세그멘트(코드, 힙, 스택)으로 나누는것이 아니라 고정 크기의 단위로 나눈다. 이 각각의 고정 크기 단위를 페이지(page)라고 부른다. 또한 상응하여 물리 메모리도 페이지 프레임(page frame)이라고 불리는 고정 크기의 슬롯의 배열이라고 생각한다. 이 프레임 각각은 하나의 가상 메모리 페이지를 저장할 수 있다. 

주소 공간은 전체0~64KB로  4개의 페이지로 나누면 각 16KB이다. 이를 전체 물리메모리 128KB로 가정하면 페이지 프레임이 8개가 나오므로 OS가 유지하는 빈 공간 리스트에서 가져와 4개의 페이지 프레임에 배치하면된다. 또한 힙 스택이 어느 방향으로 커지는가, 어떻게 사용되는가에 대한 가정을 하지 않아도된다.

주소 공간의 각 가상 페이지에 대한 물리 메모리 위치 기록을 위해서 __OS는 프로세스마다 페이지 테이블(page table)이라는 자료 구조를 유지한다__. 페이지 테이블의 주요 역할은 주소 공간의 가상 페이지 주소 변환 정보를 저장하는 것이다. VPN(가상주소)>>PFN(물리주소)  (즉, 가상페이지0>>물리페이지3)

![IMG_1559](https://tva1.sinaimg.cn/large/007S8ZIlgy1gira9wb8ucj31ac0sejz2.jpg)

offset은 놨두고 VPN>PFN으로 전환

![IMG_1560](https://tva1.sinaimg.cn/large/007S8ZIlgy1giraa3uri4j314x0u0qdc.jpg)



![IMG_1561](https://tva1.sinaimg.cn/large/007S8ZIlgy1giraaaqzljj315d0u0dss.jpg)

Page table은 매우 크므로 MMU안에서 유지하지 않고, 대신 각 프로ㅔ쓰의 페이지 테이블을 메모리에 저장한다. 

페이지 테이블은 가상 주소를 물리 주소로 매핑하는데 사용되는 자료구조로, 가장 간단한 형태는 선형 페이지 테이블이다. VPN로 배열의 항목(PTE)에 접근하여 PFN을 얻어낸다. 각 PTE에는 다른 심도있는 비트들도 존재한다.

protection bit, accessed bit, valid bit등등 중요함.

![스크린샷 2020-09-15 오후 2.51.05](https://tva1.sinaimg.cn/large/007S8ZIlgy1giragyuzdlj30no04aq98.jpg)

__페이징 너무 느림__

페이지 테이블로 인해 처리 속도가 매우 저하될수있다. 

명령어를 가져오는과정은

 메모리 접근에서 VPN을 PFN으로 바꾸기 위해 메모리에 있는 page table에 접근하고 다시 PFN으로 메모리에 접근하여 명령어를 가져온다 (무조건 2번이상의 메모리 처리가 필요...)(느려짐)

메모리 낭비(유용한 응용 데이터 대신 페이지 테이블로 가득참)초래한다.

![스크린샷 2020-09-15 오후 2.56.20](https://tva1.sinaimg.cn/large/007S8ZIlgy1giramf4fbsj30mc0hynju.jpg)

## 제19장 페이징: 더 빠른 변환(TLB)

ss

## 제20장 페이징: 더 작은 테이블



## 제21장 물리 메모리 크기의 극복: 메커니즘



## 제22장 물리 메모리 크기의 극복: 정책



## 제23장 VAX/VMS 가상 메모리 시스템



## 제24장 메모리 가상화를 정리하는 대화





# 제Ⅱ편 병행성

## 제25장 병행성과 관한 대화



## 제26장 병행성: 개요



## 제27장 막간: 쓰레드 API



## 제28장 락



## 제29장 락 기반의 병행 자료 구조



## 제30장 컨디션 변수





## 제31장 세마포어



## 제32장 병행성 관련 오류



## 제33장 이벤트 기반의 병행성(고급)



## 제34장 병행성을 정리하는 대화





# 제Ⅲ편 영속성

## 제35장 영속성에 관한 대화



## 제36장 I/O장치



## 제37장 하드 디스크 드라이브



## 제38장 Redundant Array of Inexpensive Disk(RAID)



## 제39장 막간: 파일과 디렉터리



## 제40장 파일 시스템 구현



## 제41장 지역성과 Fast File System



## 제42장 크래시 일관성: FSCK와 저널링





## 제43장 로그 기반 파일 시스템



## 제44장 데이터 무결성과 보호



## 제45장 영속성을 정리하는 대화





## 제46장 분산에 관한 대화





## 제47장 분산 시스템





## 제48장 Sun사의 네트워크 파일 시스템(NFS)





## 제49장 Andrew 파일 시스템(AFS)





## 제50장 분산을 정리하는 대화











